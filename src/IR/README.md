# Intermediate Representation (IR)

Abstract syntax trees generated by the lexer and parser are converted to IR in
the Analysis phase. The IR contains more information than the AST about types
and variable bindings.

## Scope Internals

There are 3 different kinds of scope:

- Module scope
- Function scope
- Block scope

Function and block scopes have a parent scope determined by where the scope is
defined in the program. The language follows lexical scoping so if a lookup
fails within a function or block scope, the lookup will defer to the parent
scope.

Because of the differences in how the language manages scope and how PHP manages
scope, some variables will have to be renamed during compilation to avoid name
conflicts. In order to preserve semantics across these renames, it's crucial to
accurately track which variables refer to the same symbols. The internal API
that is used to track these relationships is the `Binding` API.

> **Eventually:** when the language analysis is advanced enough to manage
> multiple files and namespaces, `Symbol` objects will be used to preserve
> references across files even if the references have been aliased and are using
> different variable names in the source code.

### Translating scope semantics to PHP

While the semantics of module scope and function scope can be easily translated
into PHP, block scope cannot. To get around the fact that PHP does not have
block scope, the language finds any variables with the same names in nearby
block scopes and renames those variables to avoid conflicts when they are
rewritten in the same PHP scope.

### Variable declaration

During the source code analysis phase, any time a variable is **declared**, a
new `Binding` object is added to the current scope. The binding has 2 properties
of interest:

- `Binding::symbol` is a `Symbol` object and will be used by all references to
  this declaration. If the variable declared in this declaration is ever
  exported to other namespaces, any references to this variable in other
  namespaces will also reference this object.
- `Binding::name` is a `string` equal to the variable name used in this scope.
  During compilation, it is _preferred_ but not _necessary_ that this name
  continue to be used. If the compiler needs to change the name of the variable,
  that change will be communicated to all relevant identifiers using the
  `Symbol` object.

New bindings are created with the `Scope::new_binding` method which takes two
arguments: a `string` representing the variable name being bound and the `Type`
associated with the variable. The method returns a new `Symbol` used to
associate any future references to this variable.

### Variable reference

When a variable is referenced in an expression, it's not immediately clear
whether that variable exists in scope or what type it has. In order to determine
this information, the `Scope::has_binding` method is called.

The `has_binding` method takes a single argument, the `string` equal to the
variable name referenced, and returns `true` if a variable binding with that
name is in scope. It returns `false` if no variable binding with that name is in
scope.

The `get_binding` method also takes a single `string` argument equal to a
variable name and returns a `Symbol` object if that binding exists in scope or
throws a UndeclaredVariable error if no such binding is in scope.
