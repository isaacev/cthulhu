--
-- Define the primitive types and accompanying binary operators
--

pub use ::Kernel::Bool;

intrinsic {
  fn bool_and(Bool, Bool) -> Bool;
  fn bool_or(Bool, Bool) -> Bool;
}

#[infixr(rel)]
pub fn (&&) (a: Bool, b: Bool) -> Bool {
  bool_and(a, b)
}

#[infixr(rel)]
pub fn (||) (a: Bool, b: Bool) -> Bool {
  bool_or(a, b)
}

pub use ::Kernel::Int;

intrinsic {
  fn int_add(Int, Int) -> Int;
  fn int_sub(Int, Int) -> Int;
  fn int_mul(Int, Int) -> Int;
}

#[infix(sum)]
pub fn (+) (a: Int, b: Int) -> Int {
  int_add(a, b)
}

#[infix(sum)]
pub fn (-) (a: Int, b: Int) -> Int {
  int_sub(a, b)
}

#[infix(prod)]
pub fn (*) (a: Int, b: Int) -> Int {
  int_mul(a, b)
}

pub use ::Kernel::Float;

intrinsic {
  fn float_add(Float, Float) -> Float;
  fn float_sub(Float, Float) -> Float;
  fn float_mul(Float, Float) -> Float;
  fn float_div(Float, Float) -> Float;
}

#[infix(sum)]
pub fn (+.) (a: Float, b: Float) -> Float {
  float_add(a, b)
}

#[infix(sum)]
pub fn (-.) (a: Float, b: Float) -> Float {
  float_sub(a, b)
}

#[infix(prod)]
pub fn (*.) (a: Float, b: Float) -> Float {
  float_mul(a, b)
}

#[infix(prod)]
pub fn (/) (a: Float, b: Float) -> Float {
  float_div(a, b)
}

pub use ::Kernel::Str;

intrinsic {
  fn str_concat(Str, Str) -> Str;
}

#[infix(sum)]
pub fn (++) (a: Str, b: Str) -> Str {
  str_concat(a, b)
}

intrinsic {
  fn any_pow('a, 'a) -> 'a;
}

#[infixr(exp)]
pub fn (^) (a: 'a, b: 'a) -> 'a {
  any_pow(a, b)
}

--
-- Define other useful binary operators
--

intrinsic {
  fn any_eq('a, 'a) -> Bool;
  fn any_lt('a, 'a) -> Bool;
  fn any_gt('a, 'a) -> Bool;
  fn any_lte('a, 'a) -> Bool;
  fn any_gte('a, 'a) -> Bool;
}

#[infix(rel)]
pub fn (==) (a: 'a, b: 'a) -> Bool {
  any_eq(a, b)
}

#[infix(rel)]
pub fn (<) (a: 'a, b: 'a) -> Bool {
  any_lt(a, b)
}

#[infix(rel)]
pub fn (>) (a: 'a, b: 'a) -> Bool {
  any_gt(a, b)
}

#[infix(rel)]
pub fn (<=) (a: 'a, b: 'a) -> Bool {
  any_lte(a, b)
}

#[infix(rel)]
pub fn (>=) (a: 'a, b: 'a) -> Bool {
  any_gte(a, b)
}

#[infix(pipe)]
pub fn (|>) (lhs: 'a, rhs: 'a -> 'b) -> 'b {
  rhs(lhs)
}

--
-- Define some prefix operators
--

intrinsic {
  fn negate('a) -> 'a;
}

#[prefix]
pub fn (~) (a: 'a) -> 'a {
  negate(a)
}

--
-- Define commonly used composite types
--

pub type Maybe('a) =
  | Some('a)
  | None;

pub type Either('a, 'b) =
  | Left('a)
  | Right('b);

pub type Result('a, 'b) =
  | Ok('a)
  | Err('b);

--
-- Utility functions for common composite types
--

pub mod Maybe {
  use super::Some;
  use super::None;

  pub fn map(f: 'a -> 'b, m: super::Maybe('a)) -> super::Maybe('b) {
    match m {
      Some(a) => Some(f(a)),
      None    => None,
    }
  }

  pub fn with_default(d: 'a, m: super::Maybe('a)) -> 'a {
    match m {
      Some(a) => a,
      None    => d,
    }
  }

  pub fn or_ok(err: 'b, m: super::Maybe('a)) -> super::Result('a, 'b) {
    match m {
      Some(a) => super::Ok(a),
      None    => super::Err(err),
    }
  }
}

pub mod Either {
  use super::Left;
  use super::Right;

  pub fn map_left(f: 'a -> 'c, e: super::Either('a, 'b)) -> super::Either('c, 'b) {
    match e {
      Left(a)  => Left(f(a)),
      Right(b) => Right(b),
    }
  }

  pub fn map_right(f: 'b -> 'c, e: super::Either('a, 'b)) -> super::Either('a, 'c) {
    match e {
      Left(a)  => Left(a),
      Right(b) => Right(f(b)),
    }
  }

  pub fn left(e: super::Either('a, 'b)) -> super::Maybe('a) {
    match e {
      Left(a)  => super::Some(a),
      Right(_) => super::None,
    }
  }

  pub fn right(e: super::Either('a, 'b)) -> super::Maybe('b) {
    match e {
      Left(_)  => super::None,
      Right(b) => super::Some(b),
    }
  }
}

pub mod Result {
  use super::Ok;
  use super::Err;

  pub fn flatten(r: super::Result('a, 'a)) -> 'a {
    match r {
      Ok(a)  => a,
      Err(a) => a,
    }
  }
}
